<html>
<head>
<meta charset="utf-8">

<title>Token Volume</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

<link rel="stylesheet" href="style.css">


<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>

<script src="datahelper.js"></script>

<style>

.graph {
  font: 12px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  /*shape-rendering: crispEdges;*/
}


.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1px;
  clip-path: url(#clip);
}

.y .tick line{
    opacity: 0.2;
  }


.fadeLabel{
    opacity: 0.75;
  }
  
.legend {
    font-size: 12px;
    font-weight: bold;
    text-anchor: middle;
    fill: steelblue;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

.optionButton {
  stroke: #000;
  fill: #fff;
  shape-rendering: crispEdges;
}

.optionActive {
  stroke: #000;
  fill: #fff;
  shape-rendering: crispEdges;
}

</style>    

</head>
<body>
<nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">DAO Stats</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.html">Home</a></li>
            <li><a href="nav.html">Search</a></li>
            <li><a href="accounts.html">Accounts</a></li>
            <li class="active"><a href="tokenvol.html">Graphs</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="options.html">Options</a></li>
            <li><a href="about.html">About</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
    
    
    
    <div class="container">
      <!-- Example row of columns -->
      <div class="row">
      <a name="tknGraph"></a>
      <h3>Number of tokens in existence <a href="#tknGraph"><span class="glyphicon glyphicon-link" aria-hidden="true"></span></a></h3>
      
      <div id="graphBox" class="graph">
      </div>
      <a name="ethGraph"></a>
      <h3>Ether in contract <a href="#ethGraph"><span class="glyphicon glyphicon-link" aria-hidden="true"></span></a></h3>
      <div>
      <div id="graphBoxEth" class="graph">
      </div>
      </div>
 
      </div>
      
    </div><!-- Container end -->

    
<script src="https://d3js.org/d3.v3.min.js"></script>
<script>


//data = [[0, 0], [1, 5], [2, 10], [3, 11], [4, 5], [5, 20]];

function blockToTime(b, num){

    var bf, bl;
    if(num < b[0][0]){
        bf = b[0];
        bl = b[1];
    }
    else if(num > b[b.length-1][0]){
       bf = b[b.length-2];
       bl = b[b.length-1];
    }
    else{
       var n = num - b[0] / 1000;
       bf = b[n];
       bl = b[n+1];
    }
    
    var distance = 1000;
    var tdiff = bl[1] - bf[1];
    var factor = (num - bf[0])/distance;
    
    var t = factor * tdiff + bf[1];
    

    close = new Date(t * 1000);
    var y = close.getUTCFullYear();
    var mo = padTime(close.getUTCMonth()+1);
    var d = padTime(close.getUTCDate());
    var h = padTime(close.getUTCHours());
    var m = padTime(close.getUTCMinutes());
    var s = padTime(close.getUTCSeconds());
    
    ctext = y + "-" + mo + "-" + d + " " + h + ":" + m;
    return ctext;
}


function plotGraph(id, lines, dd, xLabel, yLabel, yTick, options){
    var self = this;
    
    if (options === undefined) options = {};

    var reference = lines[dd].data;

    var bStart = reference[0][0];
    var bEnd = reference[reference.length-1][0];
    var volMin = reference[0][1];
    var volMax = reference[0][1];
    for(var i=0; i<reference.length; i++){
        v = reference[i][1];
        if(v > volMax) volMax = v;
        else if(v < volMin) volMin = v;
    }

    var boxW = parseInt(d3.select('#graphBoxEth').style('width'), 10);
    var boxH = 500;
    
    var margin = {top: 20, right: 30, bottom: 55, left: 50},
        width = boxW - margin.left - margin.right,
        height = boxH - margin.top - margin.bottom;
        
    var marginBrush = {bottom: 30};
    var height2 = 50;
    
    xTickCount = width / 100;
    
    this.axisUpdateFns = [];
    this.updateAxes = function(){
        for(var i = 0; i < this.axisUpdateFns.length; i++){
            this.axisUpdateFns[i].apply(this);
        }
    }


    var x = d3.scale.linear()
        .range([0, width])
        .domain([bStart, bEnd]);
        
    var x2 = d3.scale.linear()
        .range([0, width])
        .domain([bStart, bEnd]);

    var y = d3.scale.linear()
        .range([height, 0])
        .domain([0, volMax]);
        
    var y2 = d3.scale.linear()
        .range([height2, 0])
        .domain([0, volMax]);

    var xAxis = this.xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(xTickCount);
        //.tickFormat(blockToTime);
        
    
    var xAxis2 = this.xAxis2 = d3.svg.axis()
        .scale(x2)
        .orient("bottom")
        .ticks(xTickCount);

    var yAxis = this.yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .tickFormat(yTick)
        .innerTickSize(-width)
        .outerTickSize(0)
        .tickPadding(10);

    var line = d3.svg.line()
        .x(function(d) { return x(d[0]); })
        .y(function(d) { return y(d[1]); });
        
    var lineBrush = d3.svg.line()
        .x(function(d) { return x(d[0]); })
        .y(function(d) { return y2(d[1]); });
    
    var brush = d3.svg.brush()
        .x(x2)
        .on("brush", function(){
            //var brush = this;
            x.domain(brush.empty() ? x.domain() : brush.extent());
            
            d3.selectAll("#" + id + " .graphSvg .line").attr("d", line);
            d3.select("#" + id + " .graphSvg .x.axis").call(self.xAxis);
        });
    /*
    var svg = d3.select("#graphBox").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");*/
        
    var svg = d3.select("#"+id)
       .append("svg")
       //responsive SVG needs these 2 attributes and no width and height attr
       //class to make it responsive
       .attr("width", width + margin.left + margin.right)
       .attr("height", height + margin.top + margin.bottom)
       .classed("graphSvg", true).append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
    svg.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);
        
    x.domain(d3.extent(lines[dd].data, function(d) { return d[0]; }));
    y.domain([0, d3.max(lines[dd].data, function(d) { return d[1]; })*1.2]);

    var xAxisElem = this.xAxisElem = svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(this.xAxis);
      
    var xAxisLabel = this.xAxisLabel = xAxisElem.append("text")
      .attr("y", 32)
      .attr("x", width/2)
      .text(xLabel);
      
    this.axisUpdateFns.push(function(){
       this.xAxisElem.call(this.xAxis); 
    });
      
    this.changeTickFormat = function(formatfn, size, label){
        xTickCount = Math.round(width / size);
        
        this.xAxis.ticks(xTickCount);
        this.xAxis.tickFormat(formatfn);
        
        this.xAxis2.ticks(xTickCount);
        this.xAxis2.tickFormat(formatfn);
        
        this.xAxisLabel.text(label);
        
        this.updateAxes();
    }
    

            
    
      
    var yAxisElem = this.yAxisElem = svg.append("g")
      .attr("class", "y axis")
      .call(yAxis);
      
    this.axisUpdateFns.push(function(){
       this.yAxisElem.call(this.yAxis); 
    });
      
      
    yAxisElem.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text(yLabel);
    
    
    var legendSpace = 0;
    var legendItems = 0;
    var legendMap = {};
    var useBrush = false;
    lines.forEach(function(thisLine, i){
        if(thisLine.legend !== undefined){
            if (thisLine.legend.group !== undefined){
                var group = thisLine.legend.group;
                if (!(group in legendMap)){
                    legendMap[group] = {colour: thisLine.colour};
                    legendSpace += 1;
                }
            }
            else{
                legendSpace += 1;
                legendItems += 1;
            }
        }
        
        if(thisLine.brush !== undefined) useBrush = true;
    });
    legendSpace = width / legendSpace;
   
    var brushSvg;
    if(useBrush){
       brushSvg = this.brushSvg = d3.select("#"+id)
        .append("svg")
       //responsive SVG needs these 2 attributes and no width and height attr
       //class to make it responsive
       .attr("width", width + margin.left + margin.right)
       .attr("height", height2 + marginBrush.bottom)
       .classed("brushSvg", true).append("g")
        .attr("transform", "translate(" + margin.left + ",0)");
        
      
    
    }
    
    
    lines.forEach(function(thisLine, i){
        
        var p =svg.append("path")
          .datum(thisLine.data)
          .attr("class", "line")
          .attr("d", line);
          
        if(thisLine.brush){
            brushSvg.append("path")
                .datum(thisLine.data)
                .attr("class", "line")
                .attr("d", lineBrush);
        
        }
          
          
        if(thisLine.colour !== undefined){
            p.style("stroke", thisLine.colour);
        }
     
        var t = false;
        if(thisLine.textLabel !== undefined){
            var l = thisLine.textLabel;
            t = svg.append("text")
               .text(l["text"] === undefined ? thisLine.name : l["text"]);

            if (l.link == "abs"){
                t.attr("y", y(l["y"]) - l["py"])
            }
            else if (l.link == "right"){
                var d = thisLine.data;
                t.attr("y", y(d[d.length-1][1]) + l["py"]);
            }

            if (l.x == "right"){
                t.attr("x", boxW - margin.right + l.px);
            }
            else if (l.x == "left"){
                var d = thisLine.data[t.y];
                t.attr("x", 10 + l.px);
            }
            
            if(l.c !== undefined){
                t.classed(l.c, true);
            }
        }
        
        if(thisLine.legend !== undefined){
            if(thisLine.legend.group === undefined){
                var label = svg.append("text")
                    .attr("x", (legendSpace/2)+i*legendSpace)  // space legend
                    .attr("y", height + (margin.bottom) - 5)
                    .attr("class", "legend")    // style the legend
                    .style("fill", thisLine.colour)
                    .text(thisLine.name); 
                    
                if (thisLine.legend.toggle){
                    label.on("click", (function(lineDOM){return function(){
                        // Determine if current line is visible 
                        console.log(lineDOM);
                        var active   = lineDOM.active ? false : true,
                        newOpacity = active ? 0 : 1; 
                        // Hide or show the elements based on the ID
                        lineDOM
                            .style("opacity", newOpacity); 
                            
                        d3.select(this).style("opacity", newOpacity*0.5 + 0.5); 
                        // Update whether or not the elements are active
                        lineDOM.active = active;
                        }}(p)));
                }
            }
            else{
                p.classed("lineGroup-" + cleanGraphClass(thisLine.legend.group), true);
                if(t != false) t.classed("lineGroup-" + cleanGraphClass(thisLine.legend.group), true);
            }
        }
        
    });
    
    Object.keys(legendMap).forEach(function(lGroup, j){
        var i = j + legendItems;
        
        var label = svg.append("text")
            .attr("x", (legendSpace/2)+i*legendSpace)  // space legend
            .attr("y", height + (margin.bottom) - 5)
            .attr("class", "legend")    // style the legend
            .style("fill", legendMap[lGroup].colour)
            .text(lGroup);
            
        
        label.on("click", function(){
            // Determine if current line is visible 
            l = legendMap[lGroup];
            console.log(l);
            lClass = "lineGroup-" + cleanGraphClass(lGroup);
            
            var active   = l.active ? false : true;
            
            console.log(active, l.active);
            newOpacity = active ? 0 : 1; 
            // Hide or show the elements based on the ID
            d3.selectAll("." + lClass)
                .style("opacity", newOpacity); 
                
                
            d3.select(this).style("opacity", newOpacity*0.5 + 0.5); 
            // Update whether or not the elements are active
            l.active = active;
            console.log(l);
        });
    }, this);   
    console.log("Brush: ", useBrush);
    if(useBrush){
    
      var brushAxisElem = this.brushAxisElem = this.brushSvg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height2 + ")")
          .call(this.xAxis2);
          
      console.log(this.brushSvg)
          
      
          
      this.axisUpdateFns.push(function(){
        console.log(xAxis2);
        this.brushAxisElem.call(this.xAxis2);
      });

      brushSvg.append("g")
          .attr("class", "x brush")
          .call(brush)
        .selectAll("rect")
          .attr("y", -6)
          .attr("height", height2 + 7);
    }
    
    
    
    
    var rectSize = function(r, w, h, m){
            r.transition()
                .attr("width", w)
                .attr("x", width - w - m)
                .attr("height", h)
                .attr("y", height - h - m);
    };
    
    
    if(options.button !== undefined){
        var gThis = this;
        
        var button = options.button;
        
        var buttonMargin = 10;
        var buttonWidth = 16;
        var buttonHeight = 16;
        var buttonFullWidth = 100;
        var buttonFullHeight = 20;
        var optionItem = svg.append("g")
            .style("opacity", 0.5);
        
            optionItem.append("rect")
            .classed("optionButton", true)
            .attr("x", width - buttonWidth - buttonMargin)
            .attr("y", height - buttonHeight - buttonMargin)
            .attr("width", buttonWidth)
            .attr("height", buttonHeight);
            
            optionItem.on("mouseover", function(){
                rectSize(d3.select(this).select(".optionButton"), buttonFullWidth, buttonFullHeight, buttonMargin);
                rectSize(d3.select(this).select(".optionActive"), buttonWidth/2, buttonFullHeight, buttonMargin);
                optionItem.style("opacity", 0.9);
                d3.select(this).select(".optionLabel").transition().style("opacity", 1);
            })
            .on("mouseout", function(){
                rectSize(d3.select(this).select(".optionButton"), buttonWidth, buttonHeight, buttonMargin);
                rectSize(d3.select(this).select(".optionActive"), buttonWidth/2, buttonHeight, buttonMargin);
                optionItem.style("opacity", 0.5);
                d3.select(this).select(".optionLabel").transition().style("opacity", 0);
            })
            .on("click", function(){
                this.active = !this.active;
                
                var active = d3.select(this).select(".optionActive");
                
                
                if(this.active){
                        active.style("opacity", 0.5);
                        
                        button.enable.apply(gThis, gThis);
                        //changeTickFormat.apply(blockToTime, 200);
                        
                }
                else{
                    active.style("opacity", 0);
                    
                    button.disable.apply(gThis, gThis);
                }
                
                //console.log(this.active);
            
            });
            optionItem.append("rect")
            .classed("optionActive", true)
            .attr("x", width - buttonWidth/2 - buttonMargin)
            .attr("y", height - buttonHeight - buttonMargin)
            .attr("width", buttonWidth/2)
            .attr("height", buttonHeight)
            .style("opacity", 0)
            optionItem.append("text")
            .classed("optionLabel", true)
            .attr("text-anchor", "middle")
            .attr("x", width - buttonFullWidth/2 - buttonMargin)
            .attr("y", height - buttonFullHeight/2 + 4 - buttonMargin)
            .style("opacity", 0)
            .text(button.text);
    }
    
}

function genLine(data, name, colour, textLabel){

    return {
        data: data,
        name: name,
        colour: colour,
        textLabel: textLabel
    };
}

getData("volhistory", function(data, status){

    var tokenLine = genLine(data);
    tokenLine.brush = true;
    new plotGraph("graphBox", [tokenLine], 0, "Block", "Volume", function(n){
            return Math.round(n/1000000).toLocaleString() + "M";
        }, {button: {text: "Show UTC time", enable: function(scope){this.changeTickFormat(blockToTime, 180, "Time");}
                                      , disable: function(scope){this.changeTickFormat(undefined, 100, "Block");}}});
    
    getData("bal", function(eth, status){

        /*data = [[0,0]];
        eth = [[1,1],[2,1],[3,3]];*/
        
        var startEth = 99999999;
        if (eth.length != 0) startEth = eth[0][0];
        
        
        var ethData = [];
        
        var i=0;
        while(data[i][0] < startEth){
            ethData.push([data[i][0], data[i][1] * 0.01, 0]);
            
            i++;
            if(i == data.length) break;
        }

        for(var i=0; i < eth.length; i++){
            eth[i][1] += eth[i][2] + eth[i][3];
        }
        
        
        ethData = ethData.concat(eth);
        
        ethData1st = ethData[0][0];
        ethDataLast = ethData[ethData.length-1][0];
        
        //console.log(labels);
        
        ethDataLine = genLine(ethData, "Balance");
        ethDataLine.legend = {toggle: false};
        ethDataLine.brush = true;
        
	var supplyStart = ethSupply(ethData1st);
	var supplyEnd = ethSupply(ethDataLast);

	var ethPcN = Math.floor(100*(ethData[ethData.length-1][1] / supplyEnd))+1;

        ethpcLines = [];
        pcCol = "rgba(150, 80, 50, 0.7)";
        for(var i = 1; i <= ethPcN ; i++){
            var line = genLine( [[ethData1st, supplyStart*0.01*i], [ethDataLast, supplyEnd*0.01*i]]
                                  , i + "%" + ((i==ethPcN)?" ETH supply":"")
                                  , pcCol
                                  , {x: "left", link: "right", y: 1, py: 13, px: 15, c: "fadeLabel"}
                                  );
            line.legend = {toggle: true, group: "Percent Lines"};
                                  
            ethpcLines.push(line);
                                  
        }
        
        allLines = ([ethDataLine]).concat(ethpcLines);

	
        
        new plotGraph("graphBoxEth", allLines, 0, "Block", "Ether", function(n){
            return (Math.round(n/100000)/10).toLocaleString() + "M";
        }, {button: {text: "Show UTC time", enable: function(scope){this.changeTickFormat(blockToTime, 180, "Time");}
                                      , disable: function(scope){this.changeTickFormat(undefined, 150, "Block");}}});
                                      
        /*new plotGraph("graphBox", allLines, 0, "Block", "Ether", function(n){
            return (Math.round(n/100000)/10).toLocaleString() + "M";
        }, {button: {text: "Show UTC time", enable: function(scope){this.changeTickFormat(blockToTime, 180, "Time");}
                                      , disable: function(scope){this.changeTickFormat(undefined, 150, "Block");}}});*/
    }, true);

}, true);

</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-77332805-1', 'auto');
  ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});

</script>
</body>
</html>