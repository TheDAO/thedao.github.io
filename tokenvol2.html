<html>
<head>
<meta charset="utf-8">

<title>Token Volume</title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

<link rel="stylesheet" href="style.css">


<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>

<script src="datahelper.js"></script>

<style>

.graph {
  font: 12px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
  
  
.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1px;
}

.y .tick line{
    opacity: 0.3;
  }
  
  .bar {
  fill: #888;
  stroke: #000;
  stroke-width: 1px;
  shape-rendering: crispEdges;
}

.bar:hover {
  fill: rgba(0,0,0,0) !important;
}


.fadeLabel{
    opacity: 0.75;
  }

.legend {
    font-size: 12px;
    font-weight: bold;
    text-anchor: middle;
    fill: steelblue;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

.optionButton {
  stroke: #000;
  fill: #fff;
  shape-rendering: crispEdges;
  cursor: pointer;
}

.optionActive {
  stroke: #000;
  fill: #fff;
  shape-rendering: crispEdges;
  cursor: pointer;
}

.optionLabel{
    
  cursor: pointer;
}

.labelBackground{
  opacity: 0.5;
  fill: #fff;
  shape-rendering: crispEdges;
}

.clickable{
	cursor: pointer;
}

.container {
    padding-right: 0px;
    padding-left: 0px;
}

</style>

</head>
<body>
<nav class="navbar navbar-default navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">DAO Stats</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="index.html">Home</a></li>
            <li><a href="nav.html">Search</a></li>
            <li><a href="accounts.html">Accounts</a></li>
            <li class="active"><a href="tokenvol.html">Graphs</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="options.html">Options</a></li>
            <li><a href="about.html">About</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>



    <div class="container">
      <!-- Example row of columns -->
      <div class="row">
      <a name="tknGraph"></a>
      <h3>Number of tokens in existence <a href="#tknGraph"><span class="glyphicon glyphicon-link" aria-hidden="true"></span></a></h3>

      <div id="graphBox" class="graph">
      </div>
      <a name="ethGraph"></a>
      <h3>Ether in contract <a href="#ethGraph"><span class="glyphicon glyphicon-link" aria-hidden="true"></span></a></h3>
      <div>
      <div id="graphBoxEth" class="graph">
      </div>
      </div>

      </div>

    </div><!-- Container end -->


<script src="https://d3js.org/d3.v3.min.js"></script>
<script>


//data = [[0, 0], [1, 5], [2, 10], [3, 11], [4, 5], [5, 20]];

function blockToTime(num){
    var b = blockTimeArray;


    var bf, bl;
    if(num < b[0][0]){
        bf = b[0];
        bl = b[1];
    }
    else if(num >= b[b.length-1][0]){
       bf = b[b.length-2];
       bl = b[b.length-1];
    }
    else{
       var n = (num - b[0][0]) / 1000;
       n = Math.floor(n);
       bf = b[n];
       bl = b[n+1];
    }

    var distance = 1000;
    var tdiff = bl[1] - bf[1];
    var factor = (num - bf[0])/distance;

    var t = factor * tdiff + bf[1];


    close = new Date(t * 1000);

    return close;
}

function getBarOpacity(range, time){

    var t1, t2;
    if(!time){
        t1 = blockToTime(range[0]).getTime();
        t2 = blockToTime(range[1]).getTime();
    }
    else{
        t1 = range[0].getTime();
        t2 = range[1].getTime();
    }
    
    var days = (t2-t1)/(1000*60*60*24);
    
    if(days > 3)return 1;
    if(days >1)return ((days-1)*0.5);
    return 0;

}

function get10AMIntervals(start, stop, interval){
    if(interval === undefined) interval = 24;
    var d = d3.time.hours.utc(new Date(start.getTime() - (1000*60*60*9)), new Date(stop.getTime() - (1000*60*60*9)), interval);

    d.forEach(function(e, i, h){
        h[i].setUTCHours(e.getUTCHours() + 9);
        if(h[i].getTime() > stop.getTime()){
            h[i] = new Date(h[0].getTime());
            h[i].setUTCHours(h[i].getUTCHours() - interval);

        }
    });

    return d;
}
function get10HIntervals(start, stop){
    return get10AMIntervals(start, stop, 12);
}
function getDIntervals(start, stop, interval){
    if(interval === undefined) interval = 1;

    var d = d3.time.days.utc(new Date(start.getTime() - (1000*60*60*9)), new Date(stop.getTime() - (1000*60*60*9)), interval);
    d.forEach(function(e, i, h){
        h[i].setUTCHours(e.getUTCHours() + 9);

        if(h[i].getTime() > stop.getTime()){
            h[i] = new Date(h[0].getTime());
            h[i].setUTCDate(h[i].getUTCDate() - interval);
        }
    });

    return d;

}

function getNDIntervals(interval){
    return function(a,b){return getDIntervals(a, b, interval);}
}

function getXRatio(range, width){
    var diff = Math.floor((range[1].getTime() - range[0].getTime())/1000)
    var r = diff/width; //Seconds per pixel

    return r;
}

function adjustAxisLabels(axis, range, width){

    var r = getXRatio(range, width);

    var n = Math.floor(width/100);

    if (r < 15){
        axis.ticks(function(a,b){return d3.time.minutes(a, b, 30)})
            .tickFormat(d3.time.format.utc("%b %d %H:%M"))
    }
    else if (r < 30){
        axis.ticks(d3.time.hours)
            .tickFormat(d3.time.format.utc("%b %d %H:%M"))
    }
    else if (r < 60){
        axis.ticks(function(a,b){return d3.time.hours(a, b, 2)})
            .tickFormat(d3.time.format.utc("%b %d %H:%M"))
    }
    else if (r < 360){
        axis.ticks(get10HIntervals)
            .tickFormat(d3.time.format.utc("%b %d %H:%M"))
    }
    else if (r < 720){
        axis.ticks(get10AMIntervals)
            .tickFormat(d3.time.format.utc("%b %d %H:%M"))
    }
    else{
        var i = Math.ceil(r/720);
        axis.ticks(getNDIntervals(i))
            .tickFormat(d3.time.format.utc("%b %d %H:%M"))
    }


}

function getBoundaries(data){


    var bStart = data[0].xNum;
    var bEnd = data[data.length-1].xNum;
    var volMin = data[0].y;
    var volMax = data[0].y;
    for(var i=0; i<data.length; i++){
        v = data[i].y;
        if(v > volMax) volMax = v;
        else if(v < volMin) volMin = v;
    }

    return {x: [bStart, bEnd],
            y: [volMin, volMax]};

}

function plotGraph(id, lines, dd, xLabel, yLabel, yTick, options){
    var self = this;

    if (options === undefined) options = {};

    
    
    var reference = lines[dd[0]];
    var refData = reference.data;
    var boundaries = getBoundaries(refData);
    
    var useYRight = false;
    if (dd.length == 2){
        useYRight = true;
        boundariesR = getBoundaries(lines[dd[1]].data);
    }
    
    var wH = window.innerHeight
|| document.documentElement.clientHeight
|| document.body.clientHeight;

    var boxW = parseInt(d3.select('#graphBoxEth').style('width'), 10);
    var boxH = wH - 150;

    var margin = {top: 20, right: useYRight?50:30, bottom: 55, left: 50},
        width = boxW - margin.left - margin.right,
        height = boxH - margin.top - margin.bottom;
        
    console.log(margin);

    self.width = width;
    self.height = height;

    var marginBrush = {bottom: 30};
    var height2 = 50;

    xTickCount = width / 100;

    this.axisUpdateFns = [];
    this.updateAxes = function(){
        for(var i = 0; i < this.axisUpdateFns.length; i++){
            this.axisUpdateFns[i].apply(this);
        }
    }

    var xNum = false;
    var xTime = false;
    if (reference.type == "num" || reference.type == "dual") xNum = true;
    if (reference.type == "time" || reference.type == "dual") xTime = true;

    var x, x2;

    var bStart = boundaries.x[0],
        bEnd = boundaries.x[1];
        
    if (xNum){
        var xScaleNum = this.xScaleNum = d3.scale.linear()
            .range([0, width])
            .domain([bStart, bEnd]);

        var xScaleNum2 = this.xScaleNum2 = d3.scale.linear()
            .range([0, width])
            .domain([bStart, bEnd]);

        self.x = xScaleNum;
        self.x2 = xScaleNum2;

        self.xAxisMode = "xNum";

    }

    if(xTime){
        var d = [blockToTime(bStart),  blockToTime(bEnd)]
        var xScaleTime = this.xScaleTime = d3.time.scale.utc()
            .range([0, width])
            .domain(d);

        var xScaleTime2 = this.xScaleTime2 = d3.time.scale.utc()
            .range([0, width])
            .domain(d);

    }


    var y = self.y = d3.scale.linear()
        .domain([0, boundaries.y[1]*1.1])
        .range([height, 0]);
        
    var yR;
    if (useYRight){
        var lm = boundaries.y[1]*1.1;
        var rm = boundariesR.y[1]*1.1;
        
        var f = lm / rm;
        if (f < 1){
            f = 1/f;
            f = Math.floor(f);
        }
        else f = Math.ceil(f);
        
        yR = self.yR = d3.scale.linear()
        .domain([0, lm / f])
        .range([height, 0]);
    }
    
    var y2 = self.y2 = d3.scale.linear()
        .domain([0, boundaries.y[1]*1.1])
        .range([height2, 0]);


    var xAxis = this.xAxis = d3.svg.axis()
        .scale(this.x)
        .orient("bottom")
        .ticks(xTickCount);
        //.tickFormat(blockToTime);




    var xAxis2 = this.xAxis2 = d3.svg.axis()
        .scale(this.x2)
        .orient("bottom")
        .ticks(xTickCount);

    var yAxis = this.yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .tickFormat(yTick)
        .innerTickSize(-width)
        .outerTickSize(0)
        .tickPadding(10);
        
    var yAxisR = undefined;
    if (useYRight){
        yAxisR = self.yAxisR = d3.svg.axis()
        .scale(yR)
        .orient("right")
        .tickFormat(yTick)  
        .outerTickSize(10)
        .tickPadding(10);
    }
    
    var line = d3.svg.line()
        .x(function(d) { return self.x(d[self.xAxisMode]); })
        .y(function(d) { return self.y(d.y); });

    var lineBrush = d3.svg.line()
        .x(function(d) { return self.x2(d[self.xAxisMode]); })
        .y(function(d) { return self.y2(d.y); });
        
    var barXFunction = function(d){ return self.x(d[self.xAxisMode]); }
    var barWFunction = function(d){ var x = d[self.xAxisMode];
                                    var a = self.x(x);
                                    var b;
                                    if (self.xAxisMode == "xNum"){
                                        b = self.x(x + d["w" + self.xAxisMode]);
                                    }
                                    else{
                                        var nx = new Date(x.getTime() + d["wxTime"])
                                        b = self.x(nx);
                                    }
                                    
                                    
                                    return b - a;}


    this.rebrush = function(){

        self.x.domain(brush.empty() ? self.x2.domain() : brush.extent());

        
        var barOpacity = 1;
        if(self.xAxisMode == "xTime"){
            adjustAxisLabels(self.xAxis, self.x.domain(), width)
            barOpacity = getBarOpacity(self.x.domain(), true);
        }
        else barOpacity = getBarOpacity(self.x.domain());
        

        d3.selectAll("#" + id + " .graphSvg .line").attr("d", line);
        d3.selectAll("#" + id + " .graphSvg .bar").attr("x", barXFunction).attr("width", barWFunction)
            .style("opacity", barOpacity);
        d3.select("#" + id + " .graphSvg .x.axis").call(self.xAxis);

    }

    var brush = self.brush = d3.svg.brush()
        .x(this.x2)
        .on("brush", self.rebrush)
        .on("brushend", self.rebrush)
    /*
    var svg = d3.select("#graphBox").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");*/

    var svgTop = d3.select("#"+id)
       .append("svg")
    .attr("width", width + margin.left + margin.right)
       .attr("height", height + margin.top + margin.bottom)
       .classed("graphSvg", true);
     
    var svg = svgTop.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    svg.append("defs").append("clipPath")
    .attr("id", "clip" + id)
  .append("rect")
    .attr("width", width)
    .attr("height", height);


    var xAxisElem = this.xAxisElem = svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(this.xAxis);

    var xAxisLabel = this.xAxisLabel = xAxisElem.append("text")
      .attr("y", 32)
      .attr("x", width/2)
      .text(xLabel);

    this.axisUpdateFns.push(function(){
       this.xAxisElem.call(this.xAxis);
    });

    this.changeTickFormat = function(scalefn, brushAxisfn, axisMode, size, label){
        var xTickCount = Math.round(width / size);

        self.xAxisMode = axisMode;

        if (scalefn !== undefined){
            var axisScale = scalefn.call(this);
            self.x = axisScale[0];
            self.x2 = axisScale[1];
        }
        else{
            self.x = self.xScaleNum;
            self.x2 = self.xScaleNum2;
        }

        self.xAxis
            .scale(self.x)
            .ticks(xTickCount)
            .tickFormat(null)

        self.xAxis2
            .scale(self.x2)
            .ticks(xTickCount)
            .tickFormat(null);

        if(brushAxisfn !== undefined){
            brushAxisfn.call(this, this.xAxis2);
        }
        else{
            this.xAxis2
                .ticks(xTickCount)
                .tickFormat(null);
        }
            //.tickSize(0)
            //.tickPadding(8);

        self.brush.x(self.x2)

        this.xAxisLabel.text(label);

        this.updateAxes();

        self.rebrush();
    }





    var yAxisElem = this.yAxisElem = svg.append("g")
      .attr("class", "y axis")
      .call(yAxis);
    this.axisUpdateFns.push(function(){
       this.yAxisElem.call(this.yAxis);
    });
    
    yAxisElem.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text(yLabel[0]);
      
    var yAxisRElem = undefined;
    
    if(useYRight){
        yAxisRElem = this.yAxisRElem = svg.append("g")
          .attr("class", "y axis")
          .attr("transform", "translate(" + width + " ,0)")	
          .call(yAxisR);
          
        this.axisUpdateFns.push(function(){
           this.yAxisRElem.call(this.yAxisR);
        });
        
        this.yAxisRElem.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 4)
      .attr("x", -5)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text(yLabel[1]);
    }

    





    var legendSpace = 0;
    var legendItems = 0;
    var legendMap = {};
    var useBrush = false;
    lines.forEach(function(thisLine, i){
        if(thisLine.legend !== undefined){
            if (thisLine.legend.group !== undefined){
                var group = thisLine.legend.group;
                if (!(group in legendMap)){
                    legendMap[group] = {colour: thisLine.colour};
                    legendSpace += 1;
                }
            }
            else{
                legendSpace += 1;
                legendItems += 1;
            }
        }

        if(thisLine.brush !== undefined) useBrush = true;
    });
    legendSpace = width / legendSpace;

    var brushSvg;
    if(useBrush){
       brushSvg = this.brushSvg = d3.select("#"+id)
        .append("svg")
       //responsive SVG needs these 2 attributes and no width and height attr
       //class to make it responsive
       .attr("width", width + margin.left + margin.right)
       .attr("height", height2 + marginBrush.bottom)
       .classed("brushSvg", true).append("g")
        .attr("transform", "translate(" + margin.left + ",0)");



    }

    var labelContainer = svg.append("g");
    var legendCounter = 0;
    console.log(self.y)
    lines.forEach(function(thisLine, i){
        
        
        var colourAttrib = "stroke";
        
        if (thisLine.chart == "line"){
            var p =svg.append("path")
              .datum(thisLine.data)
              .attr("class", "line")
              .attr("clip-path", "url(#clip" + id + ")")
              .attr("d", line);

            if(thisLine.brush){
                brushSvg.append("path")
                    .datum(thisLine.data)
                    .attr("class", "line")
                    .attr("d", lineBrush);

            }
        }
        else{
            var pos = thisLine.position;
            
            var p =svg.selectAll(".bar")
              .data(thisLine.data)
              .enter().append("rect")
              .attr("class", "bar")
              .attr("clip-path", "url(#clip" + id + ")")
              .attr("x", barXFunction)
              .attr("width", barWFunction)  
              .attr("y", pos == "l"?function(d) { return self.y(d.y); }:function(d) { return self.yR(d.y); } )
              .attr("height",  pos == "l"?function(d) { return  height - self.y(d.y); }:function(d) { return  height - self.yR(d.y); }   );
        
            colourAttrib = "fill";
        }

        if(thisLine.colour !== undefined){
            p.style(colourAttrib, thisLine.colour);
        }

        var tg = false;
        if(thisLine.textLabel !== undefined){
            var l = thisLine.textLabel;
            tg = labelContainer.append("g")
            var r = tg.append("rect");
            
            var t = tg.append("text")
               .text(l["text"] === undefined ? thisLine.name : l["text"]);

            if (l.link == "abs"){
                t.attr("y", y(l["y"]) - l["py"])
            }
            else if (l.link == "right"){
                var d = thisLine.data;
                t.attr("y", y(d[d.length-1].y) + l["py"]);
            }

            if (l.x == "right"){
                t.attr("x", boxW - margin.right + l.px);
            }
            else if (l.x == "left"){
                var d = thisLine.data[t.y];
                t.attr("x", 10 + l.px);
            }

            if(l.c !== undefined){
                t.classed(l.c, true);
            }
            
            var bbox = t.node().getBBox();
            var tWidth = bbox.width-1
            var tHeight = bbox.height-1
            
            r.attr("x", t.attr("x"))
             .attr("y", t.attr("y") - tHeight+1)
             .attr("width", tWidth)
             .attr("height", tHeight)
             .classed("labelBackground", true)
            
        }

        if(thisLine.legend !== undefined){
            if(thisLine.legend.group === undefined){
                console.log("Legend", thisLine.name)
                var label = svg.append("text")
                    .attr("x", (legendSpace/2)+legendCounter*legendSpace)  // space legend
                    .attr("y", height + (margin.bottom) - 5)
                    .attr("class", "legend")    // style the legend
                    .style("fill", thisLine.colour)
                    .text("Click to hide")
                    .style("opacity", 1);

                label.transition()
                    .style("opacity", 0)
                    .duration(1000)
                    .delay(500)
                    .transition()
                    .duration(1000)
                    .style("opacity", 1)
                    .text(thisLine.name);
                    
                legendCounter++;
                    
                console.log(label, legendSpace);
                    

                if (thisLine.legend.toggle){
                    label.on("click", (function(lineDOM){return function(){
                        // Determine if current line is visible
                        console.log(lineDOM);
                        var active   = lineDOM.active ? false : true,
                        newVisibility = active ? "hidden" : "visible";
                        newOpacity = active ? 0 : 1;
                        // Hide or show the elements based on the ID
                        lineDOM
                            .style("visibility", newVisibility);

                        d3.select(this).style("opacity", newOpacity*0.5 + 0.5);
                        // Update whether or not the elements are active
                        lineDOM.active = active;
                        }}(p)))
                     .classed("clickable", true);
                }
            }
            else{
                p.classed("lineGroup-" + cleanGraphClass(thisLine.legend.group), true);
                if(tg != false) tg.classed("lineGroup-" + cleanGraphClass(thisLine.legend.group), true);
            }
        }

    });

    Object.keys(legendMap).forEach(function(lGroup, j){
        var i = j + legendItems;

        var label = svg.append("text")
            .attr("x", (legendSpace/2)+i*legendSpace)  // space legend
            .attr("y", height + (margin.bottom) - 5)
            .attr("class", "legend")    // style the legend
            .style("fill", legendMap[lGroup].colour)
            .text("Click to hide")
            .classed("clickable", true);
        
        label.transition()
                    .style("opacity", 0)
                    .duration(1000)
                    .transition()
                    .duration(1000)
                    .style("opacity", 1)
                    .text(lGroup);
            
        label.transition()
            .style("opacity", 1)


        label.on("click", function(){
            // Determine if current line is visible
            l = legendMap[lGroup];
            console.log(l);
            lClass = "lineGroup-" + cleanGraphClass(lGroup);

            var active   = l.active ? false : true;

            console.log(active, l.active);
            newOpacity = active ? 0 : 1;
            // Hide or show the elements based on the ID
            d3.selectAll("." + lClass)
                .style("opacity", newOpacity);


            d3.select(this).style("opacity", newOpacity*0.5 + 0.5);
            // Update whether or not the elements are active
            l.active = active;
            console.log(l);
        });
    }, this);
    if(useBrush){

      var brushAxisElem = this.brushAxisElem = this.brushSvg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height2 + ")")
          .call(this.xAxis2);

      this.axisUpdateFns.push(function(){
        this.brushAxisElem.call(this.xAxis2);
      });

      brushSvg.append("g")
          .attr("class", "x brush")
          .call(brush)
        .selectAll("rect")
          .attr("y", -6)
          .attr("height", height2 + 7);
    }




    var rectSize = function(r, w, h, m){
            r.transition()
                .attr("width", w)
                .attr("x", width - w - m)
                .attr("height", h)
                .attr("y", height - h - m);
    };


    if(options.button !== undefined){
        var gThis = this;

        var button = options.button;

        var buttonMargin = 10;
        var buttonWidth = 16;
        var buttonHeight = 16;
        var buttonFullWidth = 100;
        var buttonFullHeight = 20;
        var optionItem = svg.append("g")
            .style("opacity", 0.5);

            optionItem.append("rect")
            .classed("optionButton", true)
            .attr("x", width - buttonWidth - buttonMargin)
            .attr("y", height - buttonHeight - buttonMargin)
            .attr("width", buttonWidth)
            .attr("height", buttonHeight);

            optionItem.on("mouseover", function(){
                rectSize(d3.select(this).select(".optionButton"), buttonFullWidth, buttonFullHeight, buttonMargin);
                rectSize(d3.select(this).select(".optionActive"), buttonWidth/2, buttonFullHeight, buttonMargin);
                optionItem.style("opacity", 0.9);
                d3.select(this).select(".optionLabel").transition().style("opacity", 1);
            })
            .on("mouseout", function(){
                rectSize(d3.select(this).select(".optionButton"), buttonWidth, buttonHeight, buttonMargin);
                rectSize(d3.select(this).select(".optionActive"), buttonWidth/2, buttonHeight, buttonMargin);
                optionItem.style("opacity", 0.5);
                d3.select(this).select(".optionLabel").transition().style("opacity", 0);
            })
            .on("click", function(){
                this.active = !this.active;

                var active = d3.select(this).select(".optionActive");


                if(this.active){
                        active.style("opacity", 0.5);

                        button.enable.apply(gThis, gThis);
                        //changeTickFormat.apply(blockToTime, 200);

                }
                else{
                    active.style("opacity", 0);

                    button.disable.apply(gThis, gThis);
                }

                //console.log(this.active);

            });
            optionItem.append("rect")
            .classed("optionActive", true)
            .attr("x", width - buttonWidth/2 - buttonMargin)
            .attr("y", height - buttonHeight - buttonMargin)
            .attr("width", buttonWidth/2)
            .attr("height", buttonHeight)
            .style("opacity", 0)
            optionItem.append("text")
            .classed("optionLabel", true)
            .attr("text-anchor", "middle")
            .attr("x", width - buttonFullWidth/2 - buttonMargin)
            .attr("y", height - buttonFullHeight/2 + 4 - buttonMargin)
            .style("opacity", 0)
            .text(button.text);
            
            optionItem.on("mouseover").call(optionItem.node());
    }

}

function genLine(data, name, colour, textLabel){

    var d = []

    for(var i=0; i<data.length; i++){
        d.push({
            xNum: data[i][0],
            xTime: blockToTime(data[i][0]),
            y: data[i][1]
        })
    }

    return genLineDict(d, name, colour, textLabel);
}

function genLineDict(data, name, colour, textLabel){

    return {
        data: data,
        name: name,
        colour: colour,
        textLabel: textLabel,
        chart: "line",
        position: "l"
    };
}

function genBarsDict(data, name, colour, textLabel){
    return {
        data: data,
        name: name,
        colour: colour,
        textLabel: textLabel,
        chart: "bars",
        position: "l"
    };


}

function groupData(data, start, interval){

    var tLimit = start;
    
    
    var r=0;
    var b=[];
    
    var t={y: 0}
    var blockStart = data[0].xNum;
    var volStart = data[0].y;
    for (var  i=0; i<data.length; i++){
        //console.log(data[i]);
        if(data[i].xTime.getTime() > tLimit){
            t.xTime = new Date(tLimit-interval);
            t.xNum = blockStart;
            t.y = data[i].y - volStart;
            t.wxTime = interval;
            t.wxNum = -blockStart + data[i].xNum
            b.push(t);
            t = {};
            tLimit += interval;
            blockStart = data[i].xNum;
            volStart = data[i].y;
        }
    }
    var prevt = b[b.length-1];
    t.xTime = new Date(tLimit - interval);
    t.xNum = prevt.xNum + prevt.wxNum;
    t.wxNum = prevt.wxNum;
    t.y = data[data.length-1].y - volStart;
    t.wxTime = interval;
    b.push(t);
    
    //b[0].wxNum = b[1].wxNum;
    //b[0].wxTime = b[1].wxTime;

    return b;

}

getData("volhistory", function(data, status){

    getData("blocktime", function(bdata, bstatus){

    blockTimeArray = bdata;

    var tokenLine = genLine(data, "Cumulative Volume");
    tokenLine.brush = true;
    tokenLine.type = "dual";
    tokenLine.legend = {toggle: true};
    
    var barStart = new Date(tokenLine.data[0].xTime.getTime());
    var dayStart = new Date(barStart.getTime())
    dayStart.setUTCHours(9);
    dayStart.setUTCMinutes(0);
    dayStart.setUTCSeconds(0);
    dayStart.setUTCMilliseconds(0);
    if (barStart.getTime() > dayStart.getTime()) dayStart.setUTCDate(dayStart.getUTCDate() + 1);
    var bars = groupData(tokenLine.data, dayStart.getTime(), 1000*60*60*24);
    
    console.log(bars);
    
    var gBars = genBarsDict(bars, "New Volume", "#B59647");
    gBars.position = "r";
    gBars.legend = {toggle: true};
    
    volGraph = new plotGraph("graphBox", [gBars, tokenLine], [1, 0], "Block", ["Cumulative Volume", "New Volume"],
            function(n){
            //console.log(n);
            return Math.round(n/1000000).toLocaleString() + "M";
        },
        {button: {text: "Show UTC time",
                     enable: function(){
                        this.changeTickFormat(
                            function(){return [this.xScaleTime, this.xScaleTime2];},
                            function(axis){
                                console.log(this);
                                var r = getXRatio(this.xScaleTime2.domain(), this.width);
                                var n = Math.floor(r / 1000);
                                axis
                                    .ticks(getNDIntervals(n))
                                    .tickFormat(d3.time.format('%b %d'));
                            }, "xTime", 180, "Time");}
                                      , disable: function(){this.changeTickFormat(undefined, undefined, "xNum", 100, "Block");}}});

    getData("bal", function(eth, status){

        var startEth = 99999999;
        if (eth.length != 0) startEth = eth[0][0];


        var ethData = [];

        var i=0;
        while(data[i][0] < startEth){
            var ed = Object.assign({}, tokenLine.data[i]);
            ed.y *= 0.01;
            ed.y2 = 0;
            ed.y3 = 0;

            ethData.push(ed);

            i++;
            if(i == data.length) break;
        }

        var ethL = []
        for(var i=0; i < eth.length; i++){
            eth[i][1] += eth[i][2] + eth[i][3];
            ethL.push({ xNum: eth[i][0],
                        xTime: blockToTime(eth[i][0]),
                        y: eth[i][1],
                        y2: eth[i][2],
                        y3: eth[i][3]})

        }


        ethData = ethData.concat(ethL);

        ethData1st = ethData[0].xNum;
        ethDataLast = ethData[ethData.length-1].xNum;

        //console.log(labels);

        ethDataLine = genLineDict(ethData, "Balance");
        ethDataLine.legend = {toggle: false};
        ethDataLine.brush = true;
        ethDataLine.type = "dual";

	var supplyStart = ethSupply(ethData1st);
	var supplyEnd = ethSupply(ethDataLast);


    var timeStart = blockToTime(ethData1st);
    var timeEnd = blockToTime(ethDataLast);

	var ethPcN = Math.floor(100*(ethData[ethData.length-1].y / supplyEnd))+1;

        ethpcLines = [];
        pcCol = "rgba(150, 80, 50, 0.7)";
        for(var i = 1; i <= ethPcN ; i++){
            var line = genLineDict( [{xNum: ethData1st, xTime: timeStart, y: supplyStart*0.01*i}, {xNum: ethDataLast, xTime: timeEnd, y: supplyEnd*0.01*i}]
                                  , i + "%" + ((i==ethPcN)?" ETH supply":"")
                                  , pcCol
                                  , {x: "left", link: "right", y: 1, py: 13, px: 15, c: "fadeLabel"}
                                  );
            line.legend = {toggle: true, group: "Percent Lines"};

            ethpcLines.push(line);

        }

        allLines = ([ethDataLine]).concat(ethpcLines);




        new plotGraph("graphBoxEth", allLines, [0], "Block", ["Ether"], function(n){
            return (Math.round(n/100000)/10).toLocaleString() + "M";
        }, {button: {text: "Show UTC time",
                     enable: function(){
                        this.changeTickFormat(
                            function(){return [this.xScaleTime, this.xScaleTime2];},
                            function(axis){
                                var r = getXRatio(this.xScaleTime2.domain(), this.width);
                                var n = Math.floor(r / 1000);
                                axis
                                    .ticks(getNDIntervals(n))
                                    .tickFormat(d3.time.format('%b %d'));
                            }, "xTime", 180, "Time");}
                                      , disable: function(){this.changeTickFormat(undefined, undefined, "xNum", 100, "Block");}}});

    }, true);
    }, true);

}, true);

</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-77332805-1', 'auto');
  ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});

</script>
</body>
</html>